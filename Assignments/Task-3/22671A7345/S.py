"""
Image Processing & Analysis Toolkit
Streamlit GUI using OpenCV, NumPy, and Pillow

Run: streamlit run ImageToolkit_app.py

Dependencies:
    pip install streamlit opencv-python-headless numpy pillow matplotlib

This single-file app implements the features described in the assignment:
- Image upload & info
- Color conversions
- Geometric transforms
- Filters & morphology
- Enhancement & edge detection
- Compression & save/download
- Comparison / split view
- Optional webcam (camera_input) mode

Author: Generated by ChatGPT
Deadline: Sep 8, 2025
"""

import streamlit as st
import numpy as np
import cv2
from PIL import Image, ImageOps
import io
import os
import math
import tempfile
import pathlib
import imghdr
import sys

st.set_page_config(page_title="Image Processing & Analysis Toolkit", layout="wide")

# ------------------------------- Utilities -------------------------------

def to_rgb(img_bgr):
    if img_bgr is None:
        return None
    if len(img_bgr.shape) == 2:
        return cv2.cvtColor(img_bgr, cv2.COLOR_GRAY2RGB)
    return cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)


def to_bgr(img_rgb):
    if img_rgb is None:
        return None
    if len(img_rgb.shape) == 2:
        return cv2.cvtColor(img_rgb, cv2.COLOR_GRAY2BGR)
    return cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)


def pil_from_cv2(img_bgr):
    rgb = to_rgb(img_bgr)
    return Image.fromarray(rgb)


def cv2_from_pil(pil_img):
    arr = np.array(pil_img)
    if arr.ndim == 2:
        return arr
    return cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)


def info_from_bytes(bytestr, filename=None):
    size = len(bytestr)
    fmt = None
    try:
        fmt = imghdr.what(None, h=bytestr)
    except Exception:
        fmt = None
    return size, fmt


def image_properties(img_bgr, raw_bytes=None, filename=None):
    props = {}
    if img_bgr is None:
        return props
    h, w = img_bgr.shape[:2]
    c = 1 if img_bgr.ndim == 2 else img_bgr.shape[2]
    props['Height'] = h
    props['Width'] = w
    props['Channels'] = c
    props['Shape'] = img_bgr.shape
    if raw_bytes is not None:
        size, fmt = info_from_bytes(raw_bytes, filename)
        props['File size (bytes)'] = size
        props['Format (detect)'] = fmt
    return props


# ------------------------------- Image Ops -------------------------------

def convert_color(img_bgr, mode):
    if img_bgr is None:
        return None
    if mode == 'BGR->RGB':
        return to_rgb(img_bgr)
    if mode == 'BGR->GRAY':
        return cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    if mode == 'BGR->HSV':
        return cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    if mode == 'BGR->YCrCb':
        return cv2.cvtColor(img_bgr, cv2.COLOR_BGR2YCrCb)
    if mode == 'RGB->BGR':
        return cv2.cvtColor(img_bgr, cv2.COLOR_RGB2BGR)
    return img_bgr


def rotate_image(img, angle, keep_size=True):
    if img is None:
        return None
    h, w = img.shape[:2]
    center = (w/2, h/2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    if keep_size:
        return cv2.warpAffine(img, M, (w, h))
    # compute bounding box new size
    cos = abs(M[0, 0])
    sin = abs(M[0, 1])
    new_w = int((h * sin) + (w * cos))
    new_h = int((h * cos) + (w * sin))
    M[0, 2] += (new_w / 2) - center[0]
    M[1, 2] += (new_h / 2) - center[1]
    return cv2.warpAffine(img, M, (new_w, new_h))


def scale_image(img, fx, fy):
    return cv2.resize(img, None, fx=fx, fy=fy, interpolation=cv2.INTER_LINEAR)


def translate_image(img, tx, ty):
    M = np.float32([[1, 0, tx], [0, 1, ty]])
    h, w = img.shape[:2]
    return cv2.warpAffine(img, M, (w, h))


def affine_transform(img, src_pts, dst_pts):
    M = cv2.getAffineTransform(np.float32(src_pts), np.float32(dst_pts))
    h, w = img.shape[:2]
    return cv2.warpAffine(img, M, (w, h))


def perspective_transform(img, src_pts, dst_pts):
    M = cv2.getPerspectiveTransform(np.float32(src_pts), np.float32(dst_pts))
    h, w = img.shape[:2]
    return cv2.warpPerspective(img, M, (w, h))


def apply_blur(img, method, ksize):
    if method == 'Gaussian':
        return cv2.GaussianBlur(img, (ksize, ksize), 0)
    if method == 'Median':
        return cv2.medianBlur(img, ksize)
    if method == 'Mean':
        return cv2.blur(img, (ksize, ksize))
    return img


def edge_filters(img, method, ksize=3):
    if img is None:
        return None
    gray = img if img.ndim == 2 else cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    if method == 'Sobel':
        sx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=ksize)
        sy = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=ksize)
        sob = np.sqrt(sx**2 + sy**2)
        sob = np.uint8(np.clip(sob, 0, 255))
        return sob
    if method == 'Laplacian':
        lap = cv2.Laplacian(gray, cv2.CV_64F)
        lap = np.uint8(np.clip(np.abs(lap), 0, 255))
        return lap
    if method == 'Canny':
        # thresholds should be chosen by user ideally
        return cv2.Canny(gray, 100, 200)
    return gray


def morphological(img, op, ksize):
    kernel = np.ones((ksize, ksize), np.uint8)
    if op == 'Erode':
        return cv2.erode(img, kernel, iterations=1)
    if op == 'Dilate':
        return cv2.dilate(img, kernel, iterations=1)
    if op == 'Open':
        return cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
    if op == 'Close':
        return cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)
    return img


def histogram_equalization(img):
    if img is None:
        return None
    if img.ndim == 3:
        ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)
        y, cr, cb = cv2.split(ycrcb)
        y_eq = cv2.equalizeHist(y)
        ycrcb_eq = cv2.merge([y_eq, cr, cb])
        return cv2.cvtColor(ycrcb_eq, cv2.COLOR_YCrCb2BGR)
    else:
        return cv2.equalizeHist(img)


def contrast_stretch(img):
    # simple linear contrast stretching
    if img is None:
        return None
    in_min = np.percentile(img, 2)
    in_max = np.percentile(img, 98)
    out = (img - in_min) * (255.0 / (in_max - in_min))
    out = np.clip(out, 0, 255).astype(np.uint8)
    return out


def sharpen(img):
    kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
    return cv2.filter2D(img, -1, kernel)


def bitwise_ops(img1, img2, op):
    if img1 is None or img2 is None:
        return None
    b1 = img1 if img1.ndim == 2 else cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    b2 = img2 if img2.ndim == 2 else cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
    if op == 'AND':
        return cv2.bitwise_and(b1, b2)
    if op == 'OR':
        return cv2.bitwise_or(b1, b2)
    if op == 'XOR':
        return cv2.bitwise_xor(b1, b2)
    if op == 'NOT (img1)':
        return cv2.bitwise_not(b1)
    return b1


def save_image_bytes(img, fmt='PNG', quality=95):
    pil = pil_from_cv2(img)
    buf = io.BytesIO()
    save_kwargs = {}
    if fmt.upper() == 'JPEG' or fmt.upper() == 'JPG':
        save_kwargs['quality'] = quality
        pil.save(buf, format='JPEG', **save_kwargs)
    else:
        pil.save(buf, format=fmt.upper())
    buf.seek(0)
    return buf


# ------------------------------- Streamlit UI -------------------------------

st.title("ðŸ“¸ Image Processing & Analysis Toolkit")

# Top menu / file actions
col_top_left, col_top_right = st.columns([1, 3])
with col_top_left:
    st.markdown("**File**: Upload / Save / Mode")
with col_top_right:
    st.write(" ")

# Sidebar operations
st.sidebar.header("Operations")
mode = st.sidebar.radio("Mode", ['Image Upload', 'Camera (live)', 'Sample Images'])

uploaded_file = None
raw_bytes = None
orig_bgr = None
filename = None

if mode == 'Image Upload':
    uploaded_file = st.sidebar.file_uploader("Upload an image", type=['png','jpg','jpeg','bmp','tiff'])
    if uploaded_file is not None:
        raw_bytes = uploaded_file.read()
        try:
            pil = Image.open(io.BytesIO(raw_bytes)).convert('RGB')
            orig_bgr = cv2_from_pil(pil)
            filename = uploaded_file.name
        except Exception as e:
            st.sidebar.error(f"Cannot open image: {e}")

elif mode == 'Camera (live)':
    cam_file = st.sidebar.camera_input("Use your camera")
    if cam_file is not None:
        raw_bytes = cam_file.read()
        pil = Image.open(io.BytesIO(raw_bytes)).convert('RGB')
        orig_bgr = cv2_from_pil(pil)
        filename = 'camera_input.png'

else:
    sample = st.sidebar.selectbox('Pick sample', ['lenna','coins','chessboard'] )
    if sample == 'lenna':
        # create lenna from online is disallowed; instead produce a generated pattern as placeholder
        # We'll create a simple grayscale gradient as a sample
        arr = np.tile(np.linspace(0,255,512).astype(np.uint8), (512,1))
        orig_bgr = cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
        filename = 'sample_gradient.png'
    elif sample == 'coins':
        arr = np.zeros((400,400), dtype=np.uint8)
        cv2.circle(arr, (100,100), 60, 200, -1)
        cv2.circle(arr, (300,250), 80, 150, -1)
        orig_bgr = cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
        filename = 'sample_coins.png'
    else:
        arr = np.zeros((512,512,3), dtype=np.uint8)
        for i in range(0,512,64):
            cv2.line(arr, (i,0),(i,511),(255,255,255),1)
            cv2.line(arr, (0,i),(511,i),(255,255,255),1)
        orig_bgr = arr
        filename = 'sample_chessboard.png'

# column layout for displays
col1, col2 = st.columns([1,1])

# Sidebar: operation categories
st.sidebar.subheader('Image Info')
show_info = st.sidebar.checkbox('Show image info', value=True)

st.sidebar.subheader('Color Conversion')
color_mode = st.sidebar.selectbox('Choose color conversion', ['None','BGR->RGB','BGR->GRAY','BGR->HSV','BGR->YCrCb'])

st.sidebar.subheader('Geometric Transforms')
rotate_angle = st.sidebar.slider('Rotate (deg)', -180, 180, 0)
keep_size = st.sidebar.checkbox('Keep original size on rotate', True)
scale = st.sidebar.slider('Scale factor', 10, 300, 100)
translate_x = st.sidebar.slider('Translate X (px)', -200, 200, 0)
translate_y = st.sidebar.slider('Translate Y (px)', -200, 200, 0)
apply_affine = st.sidebar.checkbox('Apply Affine example', False)
apply_perspective = st.sidebar.checkbox('Apply Perspective example', False)

st.sidebar.subheader('Filtering & Morphology')
filter_method = st.sidebar.selectbox('Blur', ['None','Gaussian','Median','Mean'])
kernel_size = st.sidebar.slider('Kernel size (odd)', 1, 31, 3, step=2)
edge_method = st.sidebar.selectbox('Edge detection', ['None','Sobel','Laplacian','Canny'])
morph_op = st.sidebar.selectbox('Morphology', ['None','Erode','Dilate','Open','Close'])

st.sidebar.subheader('Enhancement')
apply_hist_eq = st.sidebar.checkbox('Histogram Equalization', False)
apply_contrast = st.sidebar.checkbox('Contrast Stretching', False)
apply_sharpen = st.sidebar.checkbox('Sharpening', False)

st.sidebar.subheader('Bitwise Operations')
apply_bitwise = st.sidebar.checkbox('Apply bitwise op with a second image', False)
bitwise_op = st.sidebar.selectbox('Bitwise op', ['AND','OR','XOR','NOT (img1)'])

st.sidebar.subheader('Compression / Save')
save_fmt = st.sidebar.selectbox('Save format', ['PNG','JPEG','BMP'])
jpeg_quality = st.sidebar.slider('JPEG quality', 30, 100, 95)

st.sidebar.subheader('Display Options')
comparison_mode = st.sidebar.checkbox('Comparison (split view)', False)
show_hist = st.sidebar.checkbox('Show histogram (processed)', False)

# Buttons
apply_button = st.sidebar.button('Apply all operations')
save_button = st.sidebar.button('Save processed image')

# Process image pipeline
processed = None

if orig_bgr is not None:
    img = orig_bgr.copy()

    # Color conversion (applied early so subsequent ops receive intended input)
    if color_mode != 'None':
        conv = convert_color(img, color_mode)
        # convert_color may return single channel or other; we convert back to BGR for further ops
        if isinstance(conv, np.ndarray):
            if conv.ndim == 2:
                img = cv2.cvtColor(conv, cv2.COLOR_GRAY2BGR)
            elif conv.shape[2] == 3 and color_mode != 'BGR->RGB':
                # Many conversions returned BGR-like; keep consistency
                img = conv if conv.shape[2] == 3 else cv2.cvtColor(conv, cv2.COLOR_GRAY2BGR)
            else:
                img = conv

    # rotating
    if rotate_angle != 0:
        img = rotate_image(img, rotate_angle, keep_size=keep_size)

    # scaling
    if scale != 100:
        factor = scale / 100.0
        img = scale_image(img, factor, factor)

    # translation
    if translate_x != 0 or translate_y != 0:
        img = translate_image(img, translate_x, translate_y)

    # affine example: small shear/rotate using 3 pts
    if apply_affine:
        h, w = img.shape[:2]
        src = [(0,0), (w-1,0), (0,h-1)]
        dst = [(0, int(0.2*h)), (int(0.9*w), int(0.1*h)), (int(0.1*w), int(0.8*h))]
        img = affine_transform(img, src, dst)

    # perspective example: simple quadrilateral warp
    if apply_perspective:
        h, w = img.shape[:2]
        src = [(0,0),(w-1,0),(w-1,h-1),(0,h-1)]
        dst = [(int(0.05*w), int(0.2*h)), (int(0.95*w), int(0.05*h)), (int(0.9*w), int(0.95*h)), (int(0.1*w), int(0.9*h))]
        img = perspective_transform(img, src, dst)

    # filtering
    if filter_method != 'None' and kernel_size > 1:
        img = apply_blur(img, filter_method, kernel_size)

    # morphology
    if morph_op != 'None':
        img = morphological(img, morph_op, max(1, kernel_size))

    # edge detection (we will show as grayscale result)
    if edge_method != 'None':
        edges = edge_filters(img, edge_method, ksize=3)
        # convert edges to 3-channel for consistent display
        if edges.ndim == 2:
            edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
        else:
            edges_color = edges
        img = edges_color

    # enhancement
    if apply_hist_eq:
        img = histogram_equalization(img)
    if apply_contrast:
        img = contrast_stretch(img)
    if apply_sharpen:
        img = sharpen(img)

    # bitwise (requires a second image)
    if apply_bitwise:
        # we'll let the second image be the original resized to same shape
        other = cv2.resize(orig_bgr, (img.shape[1], img.shape[0]))
        bw = bitwise_ops(img, other, bitwise_op)
        # convert to 3-channel
        if bw is not None and bw.ndim == 2:
            img = cv2.cvtColor(bw, cv2.COLOR_GRAY2BGR)
        elif bw is not None:
            img = bw

    processed = img

# Display original and processed images
with col1:
    st.subheader('Original Image')
    if orig_bgr is None:
        st.info('No image loaded. Use the sidebar to upload or pick a mode.')
    else:
        st.image(to_rgb(orig_bgr), use_column_width=True)

with col2:
    st.subheader('Processed Image')
    if processed is None:
        st.info('Processed image will appear here after operations are applied.')
    else:
        if comparison_mode and orig_bgr is not None:
            # create split view
            h = min(orig_bgr.shape[0], processed.shape[0])
            w = min(orig_bgr.shape[1], processed.shape[1])
            left = to_rgb(cv2.resize(orig_bgr, (w,h)))
            right = to_rgb(cv2.resize(processed, (w,h)))
            split = np.concatenate([left[:, :w//2, :], right[:, w//2:, :]], axis=1)
            st.image(split, use_column_width=True)
        else:
            st.image(to_rgb(processed), use_column_width=True)

# Status bar / image properties
st.markdown('---')
col_s1, col_s2, col_s3, col_s4 = st.columns([1,1,1,1])
if orig_bgr is not None:
    props = image_properties(orig_bgr, raw_bytes, filename)
    with col_s1:
        st.write(f"**Dimensions:** {props.get('Width','-')} x {props.get('Height','-')}")
    with col_s2:
        st.write(f"**Channels:** {props.get('Channels','-')}")
    with col_s3:
        fs = props.get('File size (bytes)')
        st.write(f"**File size:** {fs if fs is None else f'{fs} bytes'}")
    with col_s4:
        st.write(f"**Format:** {props.get('Format (detect)','-')}  ")
else:
    with col_s1:
        st.write('**Dimensions:** -')
    with col_s2:
        st.write('**Channels:** -')
    with col_s3:
        st.write('**File size:** -')
    with col_s4:
        st.write('**Format:** -')

# Histogram (optional)
if show_hist and processed is not None:
    st.subheader('Histogram (Processed)')
    proc = processed.copy()
    if proc.ndim == 3 and proc.shape[2] == 3:
        chans = cv2.split(proc)
        colors = ('b','g','r')
        import matplotlib.pyplot as plt
        fig = plt.figure(figsize=(8,3))
        for (chan, col) in zip(chans, colors):
            hist = cv2.calcHist([chan], [0], None, [256], [0,256])
            plt.plot(hist)
        plt.xlim([0,256])
        st.pyplot(fig)
    else:
        gray = proc if proc.ndim==2 else cv2.cvtColor(proc, cv2.COLOR_BGR2GRAY)
        import matplotlib.pyplot as plt
        fig = plt.figure(figsize=(8,3))
        hist = cv2.calcHist([gray], [0], None, [256], [0,256])
        plt.plot(hist)
        plt.xlim([0,256])
        st.pyplot(fig)

# Save / Download
if save_button and processed is not None:
    buf = save_image_bytes(processed, fmt=save_fmt, quality=jpeg_quality)
    bts = buf.getvalue()
    st.success(f"Processed image ready to download ({len(bts)} bytes)")
    st.download_button(label='Download processed image', data=bts, file_name=f'processed.{save_fmt.lower()}', mime=f'image/{save_fmt.lower()}')

# Provide save option also as a persistent file on server (optional)
if save_button and processed is not None:
    tmp_dir = tempfile.gettempdir()
    out_path = os.path.join(tmp_dir, f'processed_output.{save_fmt.lower()}')
    with open(out_path, 'wb') as f:
        f.write(save_image_bytes(processed, fmt=save_fmt, quality=jpeg_quality).getbuffer())
    st.info(f'Also saved to server temp: {out_path}')

st.markdown('---')

st.caption('Tips: Use sliders and checkboxes in the sidebar to explore operations. For webcam, enable camera permissions. This app is a learning toolkit â€” adapt and extend as needed for your assignment.')

# Footer: quick help
with st.expander('Implementation notes (click to expand)'):
    st.markdown(
        '''
- This is a single-file Streamlit app that demonstrates core OpenCV operations.
- To extend: modularize functions into separate utility files; add unit tests; add live webcam processing loop using st.camera_input in a loop; produce a downloadable PDF report using reportlab or WeasyPrint.
- If you need a Jupyter notebook version of step-by-step cells or a PDF report template, I can generate them next.
''')

# End of file
